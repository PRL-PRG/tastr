/* -*- C++ -*- */
%output  "Parser.cxx"
%defines "Parser.hxx"

%skeleton "lalr1.cc"
%require "3.5.2"

%define api.parser.class {Parser}
%define api.namespace {tastr::parser}

/* assert correct cleanup of semantic value objects */
%define parse.assert

%define parse.trace

/* increase usefulness of error messages */
%define parse.error verbose
%parse-param { tastr::parser::Lexer& lexer} { tastr::parser::ParsingContext& context }

/* call yylex with a location */
%locations

%define api.value.type variant
/* %define api.token.constructor */
%define api.token.prefix {TOKEN_}


%token EOF                          0             "end of file";
%token <std::string>                OR            "|";
%token <std::string>                EXCLAMATION   "!";
%token <std::string>                ARROW         "=>";
%token <std::string>                COMMA         ",";
%token <std::string>                DOUBLE_LPAREN "((";
%token <std::string>                LPAREN        "(";
%token <std::string>                DOUBLE_RPAREN "))";
%token <std::string>                RPAREN        ")";
%token <std::string>                LBRACKET      "[";
%token <std::string>                RBRACKET      "]";
%token <std::string>                LANGLEBRACKET "<";
%token <std::string>                RANGLEBRACKET ">";
%token <std::string>                DOUBLE_LBRACE "{{";
%token <std::string>                DOUBLE_RBRACE "}}";
%token <std::string>                SEMICOLON     ";";
%token <std::string>                COLON         ":";
%token <std::string>                VARARG        "...";
%token <std::string>                INTEGER
%token <std::string>                DOUBLE
%token <std::string>                COMPLEX
%token <std::string>                CHARACTER
%token <std::string>                LOGICAL
%token <std::string>                RAW
%token <std::string>                ENVIRONMENT
%token <std::string>                EXPRESSION
%token <std::string>                LANGUAGE
%token <std::string>                SYMBOL
%token <std::string>                TYPEDECL
%token <std::string>                IDENTIFIER;
%nterm <ScalarTypePtr>              scalartype
%nterm <EnvironmentTypePtr>         environmenttype
%nterm <ExpressionTypePtr>          expressiontype
%nterm <LanguageTypePtr>            languagetype
%nterm <SymbolTypePtr>              symboltype
%nterm <VectorTypePtr>              vectortype
%nterm <NoNaTypePtr>                nonavectortype
%nterm <sequence_ptr_t<Type>>       typeseq
%nterm <TaggedTypePtr>              namedtype
%nterm <sequence_ptr_t<TaggedType>> namedtypeseq
%nterm <TypePtr>                    paramtype
%nterm <sequence_ptr_t<Type>>       paramtypeseq
%nterm <FunctionTypePtr>            functiontype
%nterm <GroupTypePtr>               grouptype
%nterm <TypePtr>                    nonuniontype
%nterm <ListTypePtr>                listtype
%nterm <StructTypePtr>              structtype
%nterm <IdentifierPtr>              funname
%nterm <IdentifierPtr>              identifier
%nterm <TypePtr>                    type
%nterm <TypeDeclarationPtr>         decltype


%right ARROW
%nonassoc COMMA EXCLAMATION LPAREN LBRACKET LANGLEBRACKET
%left OR


%start start;

/*
%printer { yyo << to_string(*$$); } <TypePtr>;
%printer { yyo << to_string(*$$); } <VectorTypePtr>;
%printer { yyo << to_string(*$$); } <NoNaTypePtr>;
%printer { yyo << to_string(*$$); } <FunctionTypePtr>;
%printer { yyo << to_string(*$$); } <GroupTypePtr>;
%printer { yyo << to_string(*$$); } <ListTypePtr>;
%printer { yyo << to_string(*$$); } <StructTypePtr>;
%printer { yyo << to_string(*$$); } <ScalarTypePtr>;
*/
/*%printer { yyo << $$; } <*>; */

/*
%destructor { delete $$; } scalartype
%destructor { delete $$; } vectortype
%destructor { delete $$; } nonavectortype
%destructor { delete $$; } typeseq
%destructor { delete $$; } namedtypeseq
%destructor { delete $$; } functiontype
%destructor { delete $$; } grouptype
%destructor { delete $$; } nonuniontype
%destructor { delete $$; } listtype
%destructor { delete $$; } structtype
%destructor { delete $$; } type
*/


%initial-action {
    /* filename for locations here             
       https://www.gnu.org/software/bison/manual/html_node/Initial-Action-Decl.html */
    @$.initialize(context.get_input_stream_name());
}

/* inserted near top of header + source file */
%code requires {
    namespace tastr::parser {
        class Lexer;
        class ParsingContext;
    }
    #include "location.hh"
    #include "ast.h"
    using tastr::ast::CharacterType;
    using tastr::ast::ComplexType;
    using tastr::ast::DoubleType;
    using tastr::ast::ExpressionType;
    using tastr::ast::ExpressionTypePtr;
    using tastr::ast::EnvironmentType;
    using tastr::ast::EnvironmentTypePtr;
    using tastr::ast::LanguageType;
    using tastr::ast::LanguageTypePtr;
    using tastr::ast::SymbolType;
    using tastr::ast::SymbolTypePtr;
    using tastr::ast::FunctionType;
    using tastr::ast::FunctionTypePtr;
    using tastr::ast::GroupType;
    using tastr::ast::GroupTypePtr;
    using tastr::ast::IntegerType;
    using tastr::ast::ListType;
    using tastr::ast::ListTypePtr;
    using tastr::ast::LogicalType;
    using tastr::ast::TaggedType;
    using tastr::ast::TaggedTypePtr;
    using tastr::ast::TaggedTypeUPtr;
    using tastr::ast::NoNaType;
    using tastr::ast::NoNaTypePtr;
    using tastr::ast::ParameterType;
    using tastr::ast::ParameterTypePtr;
    using tastr::ast::ParameterTypeUPtr;
    using tastr::ast::RawType;
    using tastr::ast::ScalarTypePtr;
    using tastr::ast::ScalarTypeUPtr;
    using tastr::ast::sequence_t;
    using tastr::ast::sequence_ptr_t;
    using tastr::ast::sequence_uptr_t;
    using tastr::ast::StructType;
    using tastr::ast::StructTypePtr;
    using tastr::ast::Type;
    using tastr::ast::TypePtr;
    using tastr::ast::TypeUPtr;
    using tastr::ast::UnionType;
    using tastr::ast::UnionTypePtr;
    using tastr::ast::VectorType;
    using tastr::ast::VectorTypePtr;
    using tastr::ast::VectorTypeUPtr;
    using tastr::ast::TypeDeclaration;
    using tastr::ast::TypeDeclarationPtr;
    using tastr::ast::TypeDeclarationUPtr;
    using tastr::ast::TypeDeclarationSequenceUPtr;
    using tastr::ast::Identifier;
    using tastr::ast::IdentifierPtr;
    using tastr::ast::IdentifierUPtr;
    using tastr::ast::VarargType;
}

/* inserted near top of source file */
%code {
    #include "ParsingContext.h"
    #include "Lexer.hpp"
    #undef yylex
    #define yylex lexer.yylex
}

%%

scalartype:         INTEGER                                 {
                                                                $$ = new IntegerType();
                                                            }
          |         DOUBLE                                  {
                                                                $$ = new DoubleType();
                                                            }
          |         COMPLEX                                 {
                                                                $$ = new ComplexType();
                                                            }
          |         CHARACTER                               {
                                                                $$ = new CharacterType();
                                                            }
          |         LOGICAL                                 {
                                                                $$ = new LogicalType();
                                                            }
          |         RAW                                     {
                                                                $$ = new RawType();
                                                            }
          ;

environmenttype:    ENVIRONMENT                             {
                                                                $$ = new EnvironmentType();
                                                            }
               ;

expressiontype:     EXPRESSION                              {
                                                                $$ = new ExpressionType();
                                                            }
              ;

languagetype:       LANGUAGE                                {
                                                                $$ = new LanguageType();
                                                            }
            ;

symboltype:         SYMBOL                                  {
                                                                $$ = new SymbolType();
                                                            }
          ;

vectortype:         scalartype "[" "]"                      {
                                                                ScalarTypeUPtr scalar_type($1);
                                                                $$ = new VectorType(std::move(scalar_type));
                                                            }
          ;

nonavectortype:     "!" vectortype                          {
                                                                VectorTypeUPtr vector_type($2);
                                                                $$ = new NoNaType(std::move(vector_type));
                                                            }
              ;

listtype:           "((" typeseq "))"                       {
                                                                sequence_uptr_t<Type> sequence($2);
                                                                $$ = new ListType(std::move(sequence));
                                                            }
        ;

typeseq:            %empty                                  {
                                                                $$ = new sequence_t<Type>();
                                                            }
       |            type                                    {
                                                                TypeUPtr type($1);
                                                                $$ = new sequence_t<Type>();
                                                                $$ -> push_back(std::move(type));
                                                            }
       |            typeseq "," type                        {
                                                                TypeUPtr type($3);
                                                                $1 -> push_back(std::move(type));
                                                                $$ = $1;
                                                            }
       ;

structtype:         "{{" namedtypeseq "}}"                  {
                                                                sequence_uptr_t<TaggedType> sequences($2);
                                                                $$ = new StructType(std::move(sequences));
                                                            }
          ;


identifier:         INTEGER                                 { $$ = new Identifier($1); }
          |         DOUBLE                                  { $$ = new Identifier($1); }
          |         COMPLEX                                 { $$ = new Identifier($1); }
          |         CHARACTER                               { $$ = new Identifier($1); }
          |         LOGICAL                                 { $$ = new Identifier($1); }
          |         RAW                                     { $$ = new Identifier($1); }
          |         ENVIRONMENT                             { $$ = new Identifier($1); }
          |         EXPRESSION                              { $$ = new Identifier($1); }
          |         LANGUAGE                                { $$ = new Identifier($1); }
          |         SYMBOL                                  { $$ = new Identifier($1); }
          |         TYPEDECL                                { $$ = new Identifier($1); }
          |         VARARG                                  { $$ = new Identifier($1); }
          |         IDENTIFIER                              { $$ = new Identifier($1); }
          ;

namedtype:          identifier ":" type                     {
                                                                IdentifierUPtr ident($1);
                                                                TypeUPtr type($3);
                                                                $$ = new TaggedType(std::move(ident), std::move(type));
                                                            }
         ;

namedtypeseq:       %empty                                  {
                                                                $$ = new sequence_t<TaggedType>();
                                                            }
            |       namedtype                               {
                                                                TaggedTypeUPtr named_type($1);
                                                                $$ = new sequence_t<TaggedType>();
                                                                $$ -> push_back(std::move(named_type));
                                                            }
            |       namedtypeseq "," namedtype              {
                                                                TaggedTypeUPtr named_type($3);
                                                                $1 -> push_back(std::move(named_type));
                                                                $$ = $1;
                                                            }
            ;


paramtype:          type                                    {   $$ = $1;               }
         |          "..."                                   {   $$ = new VarargType(); }
         ;

paramtypeseq:       %empty                                  {
                                                                $$ = new sequence_t<Type>();
                                                            }
            |       paramtype                               {
                                                                TypeUPtr type($1);
                                                                $$ = new sequence_t<Type>();
                                                                $$ -> push_back(std::move(type));
                                                            }
            |       paramtypeseq "," paramtype              {
                                                                TypeUPtr type($3);
                                                                $1 -> push_back(std::move(type));
                                                                $$ = $1;
                                                            }
            ;

functiontype:       "<" paramtypeseq ">" "=>" type          {
                                                                sequence_uptr_t<Type> sequence($2);
                                                                ParameterTypePtr types = new ParameterType(std::move(sequence));
                                                                ParameterTypeUPtr parameter_types(types);
                                                                TypeUPtr return_type($5);
                                                                $$ = new FunctionType(std::move(parameter_types), std::move(return_type));
                                                            }

grouptype:          "(" type ")"                            {
                                                                TypeUPtr type($2);
                                                                $$ = new GroupType(std::move(type));
                                                            }
         ;

nonuniontype:       scalartype                              {   $$ = $1; }
            |       environmenttype                         {   $$ = $1; }
            |       expressiontype                          {   $$ = $1; }
            |       languagetype                            {   $$ = $1; }
            |       symboltype                              {   $$ = $1; }
            |       vectortype                              {   $$ = $1; }
            |       nonavectortype                          {   $$ = $1; }
            |       functiontype                            {   $$ = $1; }
            |       structtype                              {   $$ = $1; }
            |       listtype                                {   $$ = $1; }
            |       grouptype                               {   $$ = $1; }
            ;


type:               nonuniontype                            {   $$ = $1; }
    |               type "|" nonuniontype                   {
                                                                TypeUPtr left_type($1);
                                                                TypeUPtr right_type($3);
                                                                $$ = new UnionType(std::move(left_type), std::move(right_type));
                                                            }
    ;


funname:            INTEGER                                 { $$ = new Identifier($1); }
       |            DOUBLE                                  { $$ = new Identifier($1); }
       |            COMPLEX                                 { $$ = new Identifier($1); }
       |            CHARACTER                               { $$ = new Identifier($1); }
       |            LOGICAL                                 { $$ = new Identifier($1); }
       |            RAW                                     { $$ = new Identifier($1); }
       |            ENVIRONMENT                             { $$ = new Identifier($1); }
       |            EXPRESSION                              { $$ = new Identifier($1); }
       |            LANGUAGE                                { $$ = new Identifier($1); }
       |            SYMBOL                                  { $$ = new Identifier($1); }
       |            TYPEDECL                                { $$ = new Identifier($1); }
       |            IDENTIFIER                              { $$ = new Identifier($1); }
       ;


decltype:           TYPEDECL funname type ";"               {
                                                                IdentifierUPtr identifier($2);
                                                                TypeUPtr type($3);
                                                                $$ = new TypeDeclaration(std::move(identifier), std::move(type));
                                                            }
        ;

decllist:           decltype                                {
                                                                TypeDeclarationUPtr type_decl($1);
                                                                context.get_type_declaration_sequence() -> push_back(std::move(type_decl));
                                                            }
        |           decllist decltype                       {
                                                                TypeDeclarationUPtr type_decl($2);
                                                                context.get_type_declaration_sequence() -> push_back(std::move(type_decl));
                                                            }
        ;

start:              EOF                                     { }
     |              decllist EOF                            { }
     ;

%%

void tastr::parser::Parser::error(const location_type& location, const std::string& message) {
    std::cout << "Parser Error: " << location << " :: " << message << std::endl;
}
