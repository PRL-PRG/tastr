/* -*- C++ -*- */
%output  "Parser.cxx"
%defines "Parser.hxx"

%skeleton "lalr1.cc"
%require "3.5"

%define api.parser.class {Parser}
%define api.namespace {tastr::parser}
%define api.location.type {tastr::parser::Location}

/* assert correct cleanup of semantic value objects */
%define parse.assert

%define parse.trace

/* increase usefulness of error messages */
%define parse.error verbose
%parse-param { tastr::parser::Lexer& lexer} { tastr::parser::ParsingContext& context }

/* call yylex with a location */
%locations

%define api.value.type variant
/* %define api.token.constructor */
%define api.token.prefix {TOKEN_}

%token EOF                              0                    "end of file";
%token <std::string>                    OR                   "|";
%token <std::string>                    CARET                "^";
%token <std::string>                    ARROW                "=>";
%token <std::string>                    COMMA                ",";
%token <std::string>                    DOUBLE_LPAREN        "((";
%token <std::string>                    LPAREN               "(";
%token <std::string>                    DOUBLE_RPAREN        "))";
%token <std::string>                    RPAREN               ")";
%token <std::string>                    VECTOR_BRACKET       "[]";
%token <std::string>                    LANGLEBRACKET        "<";
%token <std::string>                    RANGLEBRACKET        ">";
%token <std::string>                    DOUBLE_LBRACKET      "[[";
%token <std::string>                    DOUBLE_RBRACKET      "]]";
%token <std::string>                    DOUBLE_LBRACE        "{{";
%token <std::string>                    DOUBLE_RBRACE        "}}";
%token <std::string>                    SEMICOLON            ";";
%token <std::string>                    COLON                ":";
%token <std::string>                    VARARG               "...";
%token <std::string>                    UNKNOWN              "???";
%token <std::string>                    NULLOP               "?";
%token <std::string>                    NULLVALUE            "null";
%token <std::string>                    INTEGER
%token <std::string>                    DOUBLE
%token <std::string>                    COMPLEX
%token <std::string>                    CHARACTER
%token <std::string>                    LOGICAL
%token <std::string>                    RAW
%token <std::string>                    ENVIRONMENT
%token <std::string>                    EXPRESSION
%token <std::string>                    LANGUAGE
%token <std::string>                    SYMBOL
%token <std::string>                    EXTERNALPOINTER
%token <std::string>                    BYTECODE
%token <std::string>                    PAIRLIST
%token <std::string>                    S4
%token <std::string>                    WEAKREF
%token <std::string>                    TUPLE
%token <std::string>                    LIST
%token <std::string>                    DATAFRAME
%token <std::string>                    STRUCT
%token <std::string>                    ANY
%token <std::string>                    TYPEDECL
%token <std::string>                    IDENTIFIER;
%token <std::string>                    QUOTED_IDENTIFIER;
%nterm <AScalarTypeNodePtr>             ascalartype
%nterm <RawAScalarTypeNodePtr>          rawascalartype
%nterm <NAScalarTypeNodePtr>            nascalartype
%nterm <ScalarTypeNodePtr>              scalartype
%nterm <EnvironmentTypeNodePtr>         environmenttype
%nterm <ExpressionTypeNodePtr>          expressiontype
%nterm <LanguageTypeNodePtr>            languagetype
%nterm <SymbolTypeNodePtr>              symboltype
%nterm <ExternalPointerTypeNodePtr>     externalptrtype
%nterm <BytecodeTypeNodePtr>            bytecodetype
%nterm <PairlistTypeNodePtr>            pairlisttype
%nterm <S4TypeNodePtr>                  s4type
%nterm <WeakReferenceTypeNodePtr>       weakreftype
%nterm <UnknownTypeNodePtr>             unknowntype
%nterm <AnyTypeNodePtr>                 anytype
%nterm <VectorTypeNodePtr>              vectortype
%nterm <NodePtr>                        typeseq
%nterm <TagTypePairNodePtr>             namedtype
%nterm <NodePtr>                        namedtypeseq
%nterm <TypeNodePtr>                    paramtype
%nterm <NodePtr>                        paramtypeseq
%nterm <NodePtr>                        params
%nterm <FunctionTypeNodePtr>            functiontype
%nterm <GroupTypeNodePtr>               grouptype
%nterm <TypeNodePtr>                    nonuniontype
%nterm <ListTypeNodePtr>                listtype
%nterm <NodePtr>                        structelements
%nterm <DataFrameTypeNodePtr>           dataframetype
%nterm <StructTypeNodePtr>              structtype
%nterm <NodePtr>                        tupleelements
%nterm <TupleTypeNodePtr>               tupletype
%nterm <IdentifierNodePtr>              identifier
%nterm <TypeNodePtr>                    uniontype
%nterm <TypeNodePtr>                    nulltype
%nterm <TypeNodePtr>                    type
%nterm <TypeDeclarationNodePtr>         decltype

%nonassoc NULLOP
%right ARROW
%nonassoc COMMA CARET LPAREN LBRACKET LANGLEBRACKET
%nonassoc LOWER_THAN_OR
%left OR


%start start;

%printer { yyo << tastr::parser::to_string(*$$); } <RawAScalarTypeNodePtr>;
%printer { yyo << tastr::parser::to_string(*$$); } <AScalarTypeNodePtr>;
%printer { yyo << tastr::parser::to_string(*$$); } <NAScalarTypeNodePtr>;
%printer { yyo << tastr::parser::to_string(*$$); } <ScalarTypeNodePtr>;
%printer { yyo << tastr::parser::to_string(*$$); } <EnvironmentTypeNodePtr>;
%printer { yyo << tastr::parser::to_string(*$$); } <ExpressionTypeNodePtr>;
%printer { yyo << tastr::parser::to_string(*$$); } <LanguageTypeNodePtr>;
%printer { yyo << tastr::parser::to_string(*$$); } <SymbolTypeNodePtr>;
%printer { yyo << tastr::parser::to_string(*$$); } <ExternalPointerTypeNodePtr>;
%printer { yyo << tastr::parser::to_string(*$$); } <BytecodeTypeNodePtr>;
%printer { yyo << tastr::parser::to_string(*$$); } <PairlistTypeNodePtr>;
%printer { yyo << tastr::parser::to_string(*$$); } <S4TypeNodePtr>;
%printer { yyo << tastr::parser::to_string(*$$); } <WeakReferenceTypeNodePtr>;
%printer { yyo << tastr::parser::to_string(*$$); } <AnyTypeNodePtr>;
%printer { yyo << tastr::parser::to_string(*$$); } <UnknownTypeNodePtr>;
%printer { yyo << tastr::parser::to_string(*$$); } <VectorTypeNodePtr>;
%printer { yyo << tastr::parser::to_string(*$$); } <NodePtr>;
%printer { yyo << tastr::parser::to_string(*$$); } <TagTypePairNodePtr>;
%printer { yyo << tastr::parser::to_string(*$$); } <FunctionTypeNodePtr>;
%printer { yyo << tastr::parser::to_string(*$$); } <GroupTypeNodePtr>;
%printer { yyo << tastr::parser::to_string(*$$); } <ListTypeNodePtr>;
%printer { yyo << tastr::parser::to_string(*$$); } <DataFrameTypeNodePtr>;
%printer { yyo << tastr::parser::to_string(*$$); } <StructTypeNodePtr>;
%printer { yyo << tastr::parser::to_string(*$$); } <TupleTypeNodePtr>;
%printer { yyo << tastr::parser::to_string(*$$); } <IdentifierNodePtr>;
%printer { yyo << tastr::parser::to_string(*$$); } <TypeNodePtr>;
%printer { yyo << tastr::parser::to_string(*$$); } <TypeDeclarationNodePtr>;
%printer { yyo << $$; } <*>;

%destructor { delete $$; } rawascalartype
%destructor { delete $$; } ascalartype
%destructor { delete $$; } nascalartype
%destructor { delete $$; } scalartype
%destructor { delete $$; } environmenttype
%destructor { delete $$; } expressiontype
%destructor { delete $$; } languagetype
%destructor { delete $$; } symboltype
%destructor { delete $$; } externalptrtype
%destructor { delete $$; } bytecodetype
%destructor { delete $$; } pairlisttype
%destructor { delete $$; } s4type
%destructor { delete $$; } weakreftype
%destructor { delete $$; } anytype
%destructor { delete $$; } unknowntype
%destructor { delete $$; } vectortype
%destructor { delete $$; } typeseq
%destructor { delete $$; } namedtype
%destructor { delete $$; } namedtypeseq
%destructor { delete $$; } paramtype
%destructor { delete $$; } paramtypeseq
%destructor { delete $$; } params
%destructor { delete $$; } functiontype
%destructor { delete $$; } grouptype
%destructor { delete $$; } nonuniontype
%destructor { delete $$; } listtype
%destructor { delete $$; } dataframetype
%destructor { delete $$; } structtype
%destructor { delete $$; } tupleelements
%destructor { delete $$; } tupletype
%destructor { delete $$; } identifier
%destructor { delete $$; } uniontype
%destructor { delete $$; } nulltype
%destructor { delete $$; } type
%destructor { delete $$; } decltype

%initial-action {
    /* filename for locations here
       https://www.gnu.org/software/bison/manual/html_node/Initial-Action-Decl.html
       location stores pointer to a string allocated elsewhere and does not delete it.
       it has been disabled for now since TopLevelNode stores the filename anyways and
       properly deallocates it.
    */

    /* @$.initialize(context.get_input_stream_name()); */
}

/* inserted near top of header + source file */
%code requires {
    namespace tastr::parser {
        class Lexer;
        class ParsingContext;
    }
    #include "parser/Location.hpp"
    #include "ast/ast.hpp"
    #include "parser/parser.hpp"
    using tastr::ast::Node;
    using tastr::ast::NodePtr;
    using tastr::ast::KeywordNode;
    using tastr::ast::KeywordNodePtr;
    using tastr::ast::OperatorNode;
    using tastr::ast::OperatorNodePtr;
    using tastr::ast::CharacterAScalarTypeNode;
    using tastr::ast::ComplexAScalarTypeNode;
    using tastr::ast::DoubleAScalarTypeNode;
    using tastr::ast::ExpressionTypeNode;
    using tastr::ast::ExpressionTypeNodePtr;
    using tastr::ast::EnvironmentTypeNode;
    using tastr::ast::EnvironmentTypeNodePtr;
    using tastr::ast::LanguageTypeNode;
    using tastr::ast::LanguageTypeNodePtr;
    using tastr::ast::SymbolTypeNode;
    using tastr::ast::SymbolTypeNodePtr;
    using tastr::ast::ExternalPointerTypeNode;
    using tastr::ast::ExternalPointerTypeNodePtr;
    using tastr::ast::BytecodeTypeNode;
    using tastr::ast::BytecodeTypeNodePtr;
    using tastr::ast::PairlistTypeNode;
    using tastr::ast::PairlistTypeNodePtr;
    using tastr::ast::S4TypeNode;
    using tastr::ast::S4TypeNodePtr;
    using tastr::ast::WeakReferenceTypeNode;
    using tastr::ast::WeakReferenceTypeNodePtr;
    using tastr::ast::UnknownTypeNode;
    using tastr::ast::UnknownTypeNodePtr;
    using tastr::ast::AnyTypeNode;
    using tastr::ast::AnyTypeNodePtr;
    using tastr::ast::ParameterNode;
    using tastr::ast::FunctionTypeNode;
    using tastr::ast::FunctionTypeNodePtr;
    using tastr::ast::GroupTypeNode;
    using tastr::ast::GroupTypeNodePtr;
    using tastr::ast::IntegerAScalarTypeNode;
    using tastr::ast::ListTypeNode;
    using tastr::ast::ListTypeNodePtr;
    using tastr::ast::LogicalAScalarTypeNode;
    using tastr::ast::TagTypePairNode;
    using tastr::ast::TagTypePairNodePtr;
    using tastr::ast::RawAScalarTypeNode;
    using tastr::ast::RawAScalarTypeNodePtr;
    using tastr::ast::ScalarTypeNodePtr;
    using tastr::ast::AScalarTypeNodePtr;
    using tastr::ast::NAScalarTypeNode;
    using tastr::ast::NAScalarTypeNodePtr;
    using tastr::ast::DataFrameTypeNode;
    using tastr::ast::DataFrameTypeNodePtr;
    using tastr::ast::StructTypeNode;
    using tastr::ast::StructTypeNodePtr;
    using tastr::ast::TupleTypeNode;
    using tastr::ast::TupleTypeNodePtr;
    using tastr::ast::TypeNode;
    using tastr::ast::TypeNodePtr;
    using tastr::ast::UnionTypeNode;
    using tastr::ast::UnionTypeNodePtr;
    using tastr::ast::VectorTypeNode;
    using tastr::ast::VectorTypeNodePtr;
    using tastr::ast::TypeDeclarationNode;
    using tastr::ast::TypeDeclarationNodePtr;
    using tastr::ast::IdentifierNode;
    using tastr::ast::IdentifierNodePtr;
    using tastr::ast::VarargTypeNode;
    using tastr::ast::NullTypeNode;
    using tastr::ast::NullableTypeNode;
    using tastr::ast::TopLevelNodeUPtr;
    using tastr::ast::CommaSeparatorNode;
    using tastr::ast::SeparatorNodePtr;
    using tastr::ast::SeparatorNode;
    using tastr::ast::EmptyNode;
    using tastr::ast::EmptyNodePtr;
    using tastr::ast::TerminatorNode;
    using tastr::ast::TerminatorNodePtr;
    using tastr::ast::EofNode;
    using tastr::ast::EofNodePtr;
    using tastr::ast::EofNodeUPtr;
}

/* inserted near top of source file */
%code {
    #include "parser/ParsingContext.hpp"
    #include "parser/Lexer.hpp"
    #undef yylex
    #define yylex lexer.yylex
// TODO op
TerminatorNodePtr create_terminator(const std::string& value,
                                    tastr::parser::Location& location,
                                    tastr::parser::ParsingContext& context) {
    TerminatorNodePtr terminator = new TerminatorNode(value);
    terminator -> set_location(location);
    return terminator;
}
// TODO op
IdentifierNodePtr create_identifier(const std::string& value,
                                    bool quoted,
                                    bool missing,
                                    tastr::parser::Location& location,
                                    tastr::parser::ParsingContext& context) {
    IdentifierNodePtr identifier = new IdentifierNode(value, quoted, missing);
    identifier -> set_location(location);
    return identifier;
}
// TODO op
OperatorNodePtr create_operator(const std::string& value,
                                tastr::parser::Location& location,
                                tastr::parser::ParsingContext& context) {
    OperatorNodePtr op = new OperatorNode(value);
    op -> set_location(location);
    return op;
}
// TODO op
SeparatorNodePtr create_separator(const std::string& value,
                                tastr::parser::Location& location,
                                tastr::parser::ParsingContext& context) {
    SeparatorNodePtr op = new SeparatorNode(value);
    op -> set_location(location);
    return op;
}

KeywordNodePtr create_keyword(const std::string& value,
                                tastr::parser::Location& location,
                                tastr::parser::ParsingContext& context) {
    KeywordNodePtr keyword = new KeywordNode(value);
    keyword -> set_location(location);
    return keyword;
}

template<typename T>
T* create_node_with_keyword(const std::string& value,
                            tastr::parser::Location& keyword_location,
                            tastr::parser::Location& node_location,
                            tastr::parser::ParsingContext& context) {
    KeywordNodePtr keyword = new KeywordNode(value);
    keyword -> set_location(keyword_location);
    T* node = new T(std::move(wrap(std::move(keyword))));
    node -> set_location(node_location);
    return node;
}
}

%%

ascalartype:        INTEGER                                 {   $$ = create_node_with_keyword<IntegerAScalarTypeNode>($1, @1, @$, context); }
          |         DOUBLE                                  {   $$ = create_node_with_keyword<DoubleAScalarTypeNode>($1, @1, @$, context); }
          |         COMPLEX                                 {   $$ = create_node_with_keyword<ComplexAScalarTypeNode>($1, @1, @$, context); }
          |         CHARACTER                               {   $$ = create_node_with_keyword<CharacterAScalarTypeNode>($1, @1, @$, context); }
          |         LOGICAL                                 {   $$ = create_node_with_keyword<LogicalAScalarTypeNode>($1, @1, @$, context); }
          ;

rawascalartype:      RAW                                    {   $$ = create_node_with_keyword<RawAScalarTypeNode>($1, @1, @$, context); }
              ;

nascalartype:       "^" ascalartype                         {
                                                                OperatorNodePtr op = create_operator($1, @1, context);
                                                                $$ = new NAScalarTypeNode(std::move(wrap(std::move(op))),
                                                                                          std::move(wrap(std::move($2))));
                                                                $$ -> set_location(@$);
                                                            }

scalartype:         ascalartype                             {
                                                                $$ = $1;
                                                                $1 = nullptr;
                                                                $$ -> set_location(@$);
                                                            }
          |         rawascalartype                          {
                                                                $$ = $1;
                                                                $1 = nullptr;
                                                                $$ -> set_location(@$);
                                                            }
          |         nascalartype                            {
                                                                $$ = $1;
                                                                $1 = nullptr;
                                                                $$ -> set_location(@$);
                                                            }
          ;

environmenttype:    ENVIRONMENT                             {   $$ = create_node_with_keyword<EnvironmentTypeNode>($1, @1, @$, context); }
               ;

expressiontype:     EXPRESSION                              {   $$ = create_node_with_keyword<ExpressionTypeNode>($1, @1, @$, context);  }
              ;

languagetype:       LANGUAGE                                {   $$ = create_node_with_keyword<LanguageTypeNode>($1, @1, @$, context);    }
            ;

symboltype:         SYMBOL                                  {   $$ = create_node_with_keyword<SymbolTypeNode>($1, @1, @$, context);      }
          ;

externalptrtype:    EXTERNALPOINTER                         {   $$ = create_node_with_keyword<ExternalPointerTypeNode>($1, @1, @$, context); }
               ;

bytecodetype:       BYTECODE                                {   $$ = create_node_with_keyword<BytecodeTypeNode>($1, @1, @$, context); }
            ;

pairlisttype:       PAIRLIST                                {   $$ = create_node_with_keyword<PairlistTypeNode>($1, @1, @$, context); }
            ;

s4type:             S4                                      {   $$ = create_node_with_keyword<S4TypeNode>($1, @1, @$, context); }
      ;

weakreftype:        WEAKREF                                 {   $$ = create_node_with_keyword<WeakReferenceTypeNode>($1, @1, @$, context); }
           ;

dataframetype:      DATAFRAME                               {   $$ = create_node_with_keyword<DataFrameTypeNode>($1, @1, @$, context); }
             ;

anytype:            ANY                                     {   $$ = create_node_with_keyword<AnyTypeNode>($1, @1, @$, context); }
       ;

unknowntype:        UNKNOWN                                 {   $$ = create_node_with_keyword<UnknownTypeNode>($1, @1, @$, context); }
           ;

vectortype:         scalartype "[]"                         {
                                                                OperatorNodePtr op = create_operator($2, @2, context);
                                                                $$ = new VectorTypeNode(std::move(wrap(std::move(op))),
                                                                                        std::move(wrap(std::move($1))));
                                                                $$ -> set_location(@$);
                                                            }
          ;

listtype:           LIST "<" type ">"                       {
                                                                KeywordNodePtr keyword = create_keyword($1, @1, context);

                                                                OperatorNodePtr left = create_operator($2, @2, context);
                                                                OperatorNodePtr right = create_operator($4, @4, context);

                                                                ParameterNode* parameter = new ParameterNode(std::move(wrap(std::move(left))),
                                                                                                             std::move(wrap(std::move(right))),
                                                                                                             std::move(wrap(std::move($3))));

                                                                $$ = new ListTypeNode(std::move(wrap(std::move(keyword))),
                                                                                      std::move(wrap(std::move(parameter))));

                                                                $$ -> set_location(@$);
                                                            }
        ;

typeseq:            type                                    {
                                                                $$ = $1;
                                                                $1 = nullptr;
                                                            }
       |            typeseq "," type                        {
                                                                SeparatorNodePtr op = create_separator($2, @2, context);
                                                                $$ = new CommaSeparatorNode(std::move(wrap(std::move(op))),
                                                                                            std::move(wrap(std::move($1))),
                                                                                            std::move(wrap(std::move($3))));
                                                                $$ -> set_location(@$);
                                                            }
       ;


structelements:     %empty                                  {
                                                                $$ = new EmptyNode();
                                                            }
              |     namedtypeseq                            {
                                                                $$ = $1;
                                                                $1 = nullptr;
                                                            }

structtype:         STRUCT "<" structelements ">"           {
                                                                KeywordNodePtr keyword = create_keyword($1, @1, context);

                                                                OperatorNodePtr left = create_operator($2, @2, context);
                                                                OperatorNodePtr right = create_operator($4, @4, context);

                                                                ParameterNode* parameter = new ParameterNode(std::move(wrap(std::move(left))),
                                                                                                             std::move(wrap(std::move(right))),
                                                                                                             std::move(wrap(std::move($3))));

                                                                $$ = new StructTypeNode(std::move(wrap(std::move(keyword))),
                                                                                        std::move(wrap(std::move(parameter))));

                                                                $$ -> set_location(@$);
                                                            }
          ;


tupleelements:     %empty                                   {
                                                                $$ = new EmptyNode();
                                                            }
             |     typeseq                                  {
                                                                $$ = $1;
                                                                $1 = nullptr;
                                                            }
             ;

tupletype:         TUPLE "<" tupleelements ">"              {
                                                                KeywordNodePtr keyword = create_keyword($1, @1, context);

                                                                OperatorNodePtr left = create_operator($2, @2, context);
                                                                OperatorNodePtr right = create_operator($4, @4, context);

                                                                ParameterNode* parameter = new ParameterNode(std::move(wrap(std::move(left))),
                                                                                                             std::move(wrap(std::move(right))),
                                                                                                             std::move(wrap(std::move($3))));

                                                                $$ = new TupleTypeNode(std::move(wrap(std::move(keyword))),
                                                                                       std::move(wrap(std::move(parameter))));

                                                                $$ -> set_location(@$);
                                                            }
         ;

identifier:         INTEGER                                 { $$ = create_identifier($1, false, false, @1, context); }
          |         DOUBLE                                  { $$ = create_identifier($1, false, false, @1, context); }
          |         COMPLEX                                 { $$ = create_identifier($1, false, false, @1, context); }
          |         CHARACTER                               { $$ = create_identifier($1, false, false, @1, context); }
          |         LOGICAL                                 { $$ = create_identifier($1, false, false, @1, context); }
          |         RAW                                     { $$ = create_identifier($1, false, false, @1, context); }
          |         ENVIRONMENT                             { $$ = create_identifier($1, false, false, @1, context); }
          |         EXPRESSION                              { $$ = create_identifier($1, false, false, @1, context); }
          |         LANGUAGE                                { $$ = create_identifier($1, false, false, @1, context); }
          |         SYMBOL                                  { $$ = create_identifier($1, false, false, @1, context); }
          |         EXTERNALPOINTER                         { $$ = create_identifier($1, false, false, @1, context); }
          |         BYTECODE                                { $$ = create_identifier($1, false, false, @1, context); }
          |         PAIRLIST                                { $$ = create_identifier($1, false, false, @1, context); }
          |         S4                                      { $$ = create_identifier($1, false, false, @1, context); }
          |         WEAKREF                                 { $$ = create_identifier($1, false, false, @1, context); }
          |         TUPLE                                   { $$ = create_identifier($1, false, false, @1, context); }
          |         LIST                                    { $$ = create_identifier($1, false, false, @1, context); }
          |         STRUCT                                  { $$ = create_identifier($1, false, false, @1, context); }
          |         DATAFRAME                               { $$ = create_identifier($1, false, false, @1, context); }
          |         ANY                                     { $$ = create_identifier($1, false, false, @1, context); }
          |         TYPEDECL                                { $$ = create_identifier($1, false, false, @1, context); }
          |         VARARG                                  { $$ = create_identifier($1, false, false, @1, context); }
          |         IDENTIFIER                              { $$ = create_identifier($1, false, false, @1, context); }
          |         QUOTED_IDENTIFIER                       { $$ = create_identifier($1, true, false, @1, context);  }
          ;

namedtype:          identifier ":" type                     {
                                                                SeparatorNodePtr separator = create_separator($2, @2, context);
                                                                $$ = new TagTypePairNode(std::move(wrap(std::move($1))),
                                                                                         std::move(wrap(std::move($3))),
                                                                                         std::move(wrap(std::move(separator))));
                                                                $$ -> set_location(@$);
                                                            }
         |          "^" ":" type                            {
                                                                SeparatorNodePtr separator = create_separator($2, @2, context);
                                                                IdentifierNodePtr id = create_identifier($1, false, true, @1, context);
                                                                $$ = new TagTypePairNode(std::move(wrap(std::move(id))),
                                                                                         std::move(wrap(std::move($3))),
                                                                                         std::move(wrap(std::move(separator))));
                                                                $$ -> set_location(@$);
                                                            }
         ;

namedtypeseq:       namedtype                               {
                                                                $$ = $1;
                                                                $1 = nullptr;
                                                            }
            |       namedtypeseq "," namedtype              {
                                                                SeparatorNodePtr op = create_separator($2, @2, context);
                                                                $$ = new CommaSeparatorNode(std::move(wrap(std::move(op))),
                                                                                            std::move(wrap(std::move($1))),
                                                                                            std::move(wrap(std::move($3))));
                                                                $$ -> set_location(@$);
                                                            }
            ;


paramtype:          type                                    {
                                                                $$ = $1;
                                                                $1 = nullptr;
                                                            }
         |          "..."                                   {   $$ = create_node_with_keyword<VarargTypeNode>($1, @1, @$, context); }
         ;

paramtypeseq:       paramtype                               {
                                                                $$ = $1;
                                                                $1 = nullptr;
                                                            }
            |       paramtypeseq "," paramtype              {
                                                                SeparatorNodePtr op = create_separator($2, @2, context);
                                                                $$ = new CommaSeparatorNode(std::move(wrap(std::move(op))),
                                                                                            std::move(wrap(std::move($1))),
                                                                                            std::move(wrap(std::move($3))));
                                                                $$ -> set_location(@$);
                                                            }
            ;

params:             "<" paramtypeseq ">"                    {
                                                                OperatorNodePtr right = create_operator($3, @3, context);
                                                                OperatorNodePtr left = create_operator($1, @1, context);
                                                                $$ = new ParameterNode(std::move(wrap(std::move(left))),
                                                                                       std::move(wrap(std::move(right))),
                                                                                       std::move(wrap(std::move($2))));
                                                                $$ -> set_location(@$);
                                                            }
      |             "<" ">"                                 {
                                                                OperatorNodePtr right = create_operator($2, @2, context);
                                                                OperatorNodePtr left = create_operator($1, @1, context);
                                                                $$ = new ParameterNode(std::move(wrap(std::move(left))),
                                                                                       std::move(wrap(std::move(right))),
                                                                                       std::move(wrap(new EmptyNode())));
                                                                $$ -> set_location(@$);
                                                            }
      |             anytype                                 {
                                                                $$ = $1;
                                                                $1 = nullptr;
                                                            }
      ;

functiontype:       params "=>" type                        {
                                                                OperatorNodePtr op = create_operator($2, @2, context);
                                                                $$ = new FunctionTypeNode(std::move(wrap(std::move(op))),
                                                                                          std::move(wrap(std::move($1))),
                                                                                          std::move(wrap(std::move($3))));
                                                                $$ -> set_location(@$);
                                                            }
            ;

grouptype:          "(" type ")"                            {
                                                                OperatorNodePtr right = create_operator($3, @3, context);
                                                                OperatorNodePtr left = create_operator($1, @1, context);
                                                                $$ = new GroupTypeNode(std::move(wrap(std::move(left))),
                                                                                       std::move(wrap(std::move(right))),
                                                                                       std::move(wrap(std::move($2))));
                                                                $$ -> set_location(@$);
                                                            }
         ;

nonuniontype:       scalartype                              {
                                                                $$ = $1;
                                                                $1 = nullptr;
                                                                $$ -> set_location(@$);
                                                            }
            |       environmenttype                         {
                                                                $$ = $1;
                                                                $1 = nullptr;
                                                                $$ -> set_location(@$);
                                                            }
            |       expressiontype                          {
                                                                $$ = $1;
                                                                $1 = nullptr;
                                                                $$ -> set_location(@$);
                                                            }
            |       languagetype                            {
                                                                $$ = $1;
                                                                $1 = nullptr;
                                                                $$ -> set_location(@$);
                                                            }
            |       symboltype                              {
                                                                $$ = $1;
                                                                $1 = nullptr;
                                                                $$ -> set_location(@$);
                                                            }
            |       externalptrtype                         {
                                                                $$ = $1;
                                                                $1 = nullptr;
                                                                $$ -> set_location(@$);
                                                            }
            |       bytecodetype                            {
                                                                $$ = $1;
                                                                $1 = nullptr;
                                                                $$ -> set_location(@$);
                                                            }
            |       pairlisttype                            {
                                                                $$ = $1;
                                                                $1 = nullptr;
                                                                $$ -> set_location(@$);
                                                            }
            |       s4type                                  {
                                                                $$ = $1;
                                                                $1 = nullptr;
                                                                $$ -> set_location(@$);
                                                            }
            |       weakreftype                             {
                                                                $$ = $1;
                                                                $1 = nullptr;
                                                                $$ -> set_location(@$);
                                                            }
            |       dataframetype                           {
                                                                $$ = $1;
                                                                $1 = nullptr;
                                                                $$ -> set_location(@$);
                                                            }
            |       vectortype                              {
                                                                $$ = $1;
                                                                $1 = nullptr;
                                                                $$ -> set_location(@$);
                                                            }
            |       functiontype                            {
                                                                $$ = $1;
                                                                $1 = nullptr;
                                                                $$ -> set_location(@$);
                                                            }
            |       structtype                              {
                                                                $$ = $1;
                                                                $1 = nullptr;
                                                                $$ -> set_location(@$);
                                                            }
            |       listtype                                {
                                                                $$ = $1;
                                                                $1 = nullptr;
                                                                $$ -> set_location(@$);
                                                            }
            |       tupletype                               {
                                                                $$ = $1;
                                                                $1 = nullptr;
                                                                $$ -> set_location(@$);
                                                            }
            |       grouptype                               {
                                                                $$ = $1;
                                                                $1 = nullptr;
                                                                $$ -> set_location(@$);
                                                            }
            |       unknowntype                             {
                                                                $$ = $1;
                                                                $1 = nullptr;
                                                                $$ -> set_location(@$);
                                                            }
            ;


uniontype:          nonuniontype                            {
                                                                $$ = $1;
                                                                $1 = nullptr;
                                                                $$ -> set_location(@$);
                                                            }
         |          uniontype OR nonuniontype               {
                                                                OperatorNodePtr op = create_operator($2, @2, context);
                                                                $$ = new UnionTypeNode(std::move(wrap(std::move(op))),
                                                                                       std::move(wrap(std::move($1))),
                                                                                       std::move(wrap(std::move($3))));
                                                                $$ -> set_location(@$);
                                                            }
         ;


nulltype:          "null"                                   {   $$ = create_node_with_keyword<NullTypeNode>($1, @1, @$, context); }
        |          "?" uniontype                            {
                                                                OperatorNodePtr op = create_operator($1, @1, context);
                                                                $$ = new NullableTypeNode(std::move(wrap(std::move(op))),
                                                                                          std::move(wrap(std::move($2))));
                                                                $$ -> set_location(@$);
                                                            }
        ;


type:               uniontype %prec LOWER_THAN_OR           {
                                                                $$ = $1;
                                                                $1 = nullptr;
                                                                $$ -> set_location(@$);
                                                            }
    |               nulltype                                {
                                                                $$ = $1;
                                                                $1 = nullptr;
                                                                $$ -> set_location(@$);
                                                            }
    |               anytype                                 {
                                                                $$ = $1;
                                                                $1 = nullptr;
                                                                $$ -> set_location(@$);
                                                            }
    ;

decltype:           TYPEDECL identifier type ";"            {
                                                                TerminatorNodePtr terminator = create_terminator($4, @4, context);
                                                                KeywordNodePtr keyword = create_keyword($1, @1, context);
                                                                $$ = new TypeDeclarationNode(std::move(wrap(std::move(keyword))),
                                                                                             std::move(wrap(std::move($2))),
                                                                                             std::move(wrap(std::move($3))),
                                                                                             std::move(wrap(std::move(terminator))));
                                                                $$ -> set_location(@$);
                                                            }
        ;

decllist:           decltype                                {
                                                                TopLevelNodeUPtr& node(context.get_parse_result().get_top_level_node());
                                                                node -> get_type_declarations().push_back(std::move(wrap(std::move($1))));
                                                            }
        |           decllist decltype                       {
                                                                TopLevelNodeUPtr& node(context.get_parse_result().get_top_level_node());
                                                                node -> get_type_declarations().push_back(std::move(wrap(std::move($2))));
                                                            }
        ;

start:              EOF                                     {
                                                                EofNodeUPtr eof = std::make_unique<EofNode>();
                                                                eof -> set_location(@1);
                                                                TopLevelNodeUPtr& node(context.get_parse_result().get_top_level_node());
                                                                node -> set_location(@$);
                                                                node -> set_eof_node(eof);
                                                            }
     |              decllist EOF                            {
                                                                EofNodeUPtr eof = std::make_unique<EofNode>();
                                                                eof -> set_location(@2);
                                                                TopLevelNodeUPtr& node(context.get_parse_result().get_top_level_node());
                                                                node -> set_location(@$);
                                                                node -> set_eof_node(eof);
                                                            }
     ;

%%

void tastr::parser::Parser::error(const location_type& location, const std::string& message) {
    context.get_parse_result().set_error(location, message);
}
