/* -*- C++ -*- */
%output  "Parser.cxx"
%defines "Parser.hxx"

%skeleton "lalr1.cc"
%require "3.5.2"

%define api.parser.class {Parser}
%define api.namespace {tastr::parser}

/* assert correct cleanup of semantic value objects */
%define parse.assert

%define parse.trace

/* increase usefulness of error messages */
%define parse.error verbose
%parse-param { tastr::parser::Lexer& lexer} { tastr::parser::ParsingContext& context }

/* call yylex with a location */
%locations

%define api.value.type variant
/* %define api.token.constructor */
%define api.token.prefix {TOKEN_}


%token EOF                              0             "end of file";
%token <std::string>                    OR            "|";
%token <std::string>                    EXCLAMATION   "!";
%token <std::string>                    ARROW         "=>";
%token <std::string>                    COMMA         ",";
%token <std::string>                    DOUBLE_LPAREN "((";
%token <std::string>                    LPAREN        "(";
%token <std::string>                    DOUBLE_RPAREN "))";
%token <std::string>                    RPAREN        ")";
%token <std::string>                    LBRACKET      "[";
%token <std::string>                    RBRACKET      "]";
%token <std::string>                    LANGLEBRACKET "<";
%token <std::string>                    RANGLEBRACKET ">";
%token <std::string>                    DOUBLE_LBRACE "{{";
%token <std::string>                    DOUBLE_RBRACE "}}";
%token <std::string>                    SEMICOLON     ";";
%token <std::string>                    COLON         ":";
%token <std::string>                    VARARG        "...";
%token <std::string>                    INTEGER
%token <std::string>                    DOUBLE
%token <std::string>                    COMPLEX
%token <std::string>                    CHARACTER
%token <std::string>                    LOGICAL
%token <std::string>                    RAW
%token <std::string>                    ENVIRONMENT
%token <std::string>                    EXPRESSION
%token <std::string>                    LANGUAGE
%token <std::string>                    SYMBOL
%token <std::string>                    EXTERNALPOINTER
%token <std::string>                    BYTECODE
%token <std::string>                    PAIRLIST
%token <std::string>                    S4
%token <std::string>                    ANY
%token <std::string>                    TYPEDECL
%token <std::string>                    IDENTIFIER;
%nterm <ScalarTypeNodePtr>              scalartype
%nterm <EnvironmentTypeNodePtr>         environmenttype
%nterm <ExpressionTypeNodePtr>          expressiontype
%nterm <LanguageTypeNodePtr>            languagetype
%nterm <SymbolTypeNodePtr>              symboltype
%nterm <ExternalPointerTypeNodePtr>     externalptrtype
%nterm <BytecodeTypeNodePtr>            bytecodetype
%nterm <PairlistTypeNodePtr>            pairlisttype
%nterm <S4TypeNodePtr>                  s4type
%nterm <AnyTypeNodePtr>                 anytype
%nterm <VectorTypeNodePtr>              vectortype
%nterm <NoNaTypeNodePtr>                nonavectortype
%nterm <TypeNodeSequenceNodePtr>        typeseq
%nterm <TagTypePairNodePtr>             namedtype
%nterm <TagTypePairNodeSequenceNodePtr> namedtypeseq
%nterm <TypeNodePtr>                    paramtype
%nterm <TypeNodeSequenceNodePtr>        paramtypeseq
%nterm <FunctionTypeNodePtr>            functiontype
%nterm <GroupTypeNodePtr>               grouptype
%nterm <TypeNodePtr>                    nonuniontype
%nterm <ListTypeNodePtr>                listtype
%nterm <StructTypeNodePtr>              structtype
%nterm <IdentifierNodePtr>              identifier
%nterm <TypeNodePtr>                    type
%nterm <TypeDeclarationNodePtr>         decltype


%right ARROW
%nonassoc COMMA EXCLAMATION LPAREN LBRACKET LANGLEBRACKET
%left OR


%start start;

%printer { yyo << to_string(*$$); } <ScalarTypeNodePtr>;
%printer { yyo << to_string(*$$); } <EnvironmentTypeNodePtr>;
%printer { yyo << to_string(*$$); } <ExpressionTypeNodePtr>;
%printer { yyo << to_string(*$$); } <LanguageTypeNodePtr>;
%printer { yyo << to_string(*$$); } <SymbolTypeNodePtr>;
%printer { yyo << to_string(*$$); } <ExternalPointerTypeNodePtr>;
%printer { yyo << to_string(*$$); } <BytecodeTypeNodePtr>;
%printer { yyo << to_string(*$$); } <PairlistTypeNodePtr>;
%printer { yyo << to_string(*$$); } <S4TypeNodePtr>;
%printer { yyo << to_string(*$$); } <AnyTypeNodePtr>;
%printer { yyo << to_string(*$$); } <VectorTypeNodePtr>;
%printer { yyo << to_string(*$$); } <NoNaTypeNodePtr>;
%printer { yyo << to_string(*$$); } <TypeNodeSequenceNodePtr>;
%printer { yyo << to_string(*$$); } <TagTypePairNodePtr>;
%printer { yyo << to_string(*$$); } <TagTypePairNodeSequenceNodePtr>;
%printer { yyo << to_string(*$$); } <FunctionTypeNodePtr>;
%printer { yyo << to_string(*$$); } <GroupTypeNodePtr>;
%printer { yyo << to_string(*$$); } <ListTypeNodePtr>;
%printer { yyo << to_string(*$$); } <StructTypeNodePtr>;
%printer { yyo << to_string(*$$); } <IdentifierNodePtr>;
%printer { yyo << to_string(*$$); } <TypeNodePtr>;
%printer { yyo << to_string(*$$); } <TypeDeclarationNodePtr>;
%printer { yyo << $$; } <*>;

%destructor { delete $$; } scalartype
%destructor { delete $$; } environmenttype
%destructor { delete $$; } expressiontype
%destructor { delete $$; } languagetype
%destructor { delete $$; } symboltype
%destructor { delete $$; } externalptrtype
%destructor { delete $$; } bytecodetype
%destructor { delete $$; } pairlisttype
%destructor { delete $$; } s4type
%destructor { delete $$; } anytype
%destructor { delete $$; } vectortype
%destructor { delete $$; } nonavectortype
%destructor { delete $$; } typeseq
%destructor { delete $$; } namedtype
%destructor { delete $$; } namedtypeseq
%destructor { delete $$; } paramtype
%destructor { delete $$; } paramtypeseq
%destructor { delete $$; } functiontype
%destructor { delete $$; } grouptype
%destructor { delete $$; } nonuniontype
%destructor { delete $$; } listtype
%destructor { delete $$; } structtype
%destructor { delete $$; } identifier
%destructor { delete $$; } type
%destructor { delete $$; } decltype

%initial-action {
    /* filename for locations here
       https://www.gnu.org/software/bison/manual/html_node/Initial-Action-Decl.html
       location stores pointer to a string allocated elsewhere and does not delete it.
       it has been disabled for now since TopLevelNode stores the filename anyways and
       properly deallocates it.
    */

    /* @$.initialize(context.get_input_stream_name()); */
}

/* inserted near top of header + source file */
%code requires {
    namespace tastr::parser {
        class Lexer;
        class ParsingContext;
    }
    #include "location.hh"
    #include "ast.h"
    using tastr::ast::CharacterScalarTypeNode;
    using tastr::ast::ComplexScalarTypeNode;
    using tastr::ast::DoubleScalarTypeNode;
    using tastr::ast::ExpressionTypeNode;
    using tastr::ast::ExpressionTypeNodePtr;
    using tastr::ast::EnvironmentTypeNode;
    using tastr::ast::EnvironmentTypeNodePtr;
    using tastr::ast::LanguageTypeNode;
    using tastr::ast::LanguageTypeNodePtr;
    using tastr::ast::SymbolTypeNode;
    using tastr::ast::SymbolTypeNodePtr;
    using tastr::ast::ExternalPointerTypeNode;
    using tastr::ast::ExternalPointerTypeNodePtr;
    using tastr::ast::BytecodeTypeNode;
    using tastr::ast::BytecodeTypeNodePtr;
    using tastr::ast::PairlistTypeNode;
    using tastr::ast::PairlistTypeNodePtr;
    using tastr::ast::S4TypeNode;
    using tastr::ast::S4TypeNodePtr;
    using tastr::ast::AnyTypeNode;
    using tastr::ast::AnyTypeNodePtr;
    using tastr::ast::FunctionTypeNode;
    using tastr::ast::FunctionTypeNodePtr;
    using tastr::ast::GroupTypeNode;
    using tastr::ast::GroupTypeNodePtr;
    using tastr::ast::IntegerScalarTypeNode;
    using tastr::ast::ListTypeNode;
    using tastr::ast::ListTypeNodePtr;
    using tastr::ast::LogicalScalarTypeNode;
    using tastr::ast::TagTypePairNode;
    using tastr::ast::TagTypePairNodePtr;
    using tastr::ast::TagTypePairNodeUPtr;
    using tastr::ast::NoNaTypeNode;
    using tastr::ast::NoNaTypeNodePtr;
    using tastr::ast::RawScalarTypeNode;
    using tastr::ast::ScalarTypeNodePtr;
    using tastr::ast::ScalarTypeNodeUPtr;
    using tastr::ast::StructTypeNode;
    using tastr::ast::StructTypeNodePtr;
    using tastr::ast::TypeNode;
    using tastr::ast::TypeNodePtr;
    using tastr::ast::TypeNodeUPtr;
    using tastr::ast::UnionTypeNode;
    using tastr::ast::UnionTypeNodePtr;
    using tastr::ast::VectorTypeNode;
    using tastr::ast::VectorTypeNodePtr;
    using tastr::ast::VectorTypeNodeUPtr;
    using tastr::ast::TypeDeclarationNode;
    using tastr::ast::TypeDeclarationNodePtr;
    using tastr::ast::TypeDeclarationNodeUPtr;
    using tastr::ast::TopLevelNodeUPtr;
    using tastr::ast::IdentifierNode;
    using tastr::ast::IdentifierNodePtr;
    using tastr::ast::IdentifierNodeUPtr;
    using tastr::ast::VarargTypeNode;
    using tastr::ast::TypeNodeSequenceNode;
    using tastr::ast::TypeNodeSequenceNodePtr;
    using tastr::ast::TypeNodeSequenceNodeUPtr;
    using tastr::ast::TagTypePairNodeSequenceNode;
    using tastr::ast::TagTypePairNodeSequenceNodePtr;
}

/* inserted near top of source file */
%code {
    #include "ParsingContext.h"
    #include "Lexer.hpp"
    #undef yylex
    #define yylex lexer.yylex
}

%%

scalartype:         INTEGER                                 {
                                                                $$ = new IntegerScalarTypeNode($1);
                                                                $$ -> set_location(@1);
                                                            }
          |         DOUBLE                                  {
                                                                $$ = new DoubleScalarTypeNode($1);
                                                                $$ -> set_location(@1);
                                                            }
          |         COMPLEX                                 {
                                                                $$ = new ComplexScalarTypeNode($1);
                                                                $$ -> set_location(@1);
                                                            }
          |         CHARACTER                               {
                                                                $$ = new CharacterScalarTypeNode($1);
                                                                $$ -> set_location(@1);
                                                            }
          |         LOGICAL                                 {
                                                                $$ = new LogicalScalarTypeNode($1);
                                                                $$ -> set_location(@1);
                                                            }
          |         RAW                                     {
                                                                $$ = new RawScalarTypeNode($1);
                                                                $$ -> set_location(@1);
                                                            }
          ;

environmenttype:    ENVIRONMENT                             {
                                                                $$ = new EnvironmentTypeNode($1);
                                                                $$ -> set_location(@1);
                                                            }
               ;

expressiontype:     EXPRESSION                              {
                                                                $$ = new ExpressionTypeNode($1);
                                                                $$ -> set_location(@1);
                                                            }
              ;

languagetype:       LANGUAGE                                {
                                                                $$ = new LanguageTypeNode($1);
                                                                $$ -> set_location(@1);
                                                            }
            ;

symboltype:         SYMBOL                                  {
                                                                $$ = new SymbolTypeNode($1);
                                                                $$ -> set_location(@1);
                                                            }
          ;

externalptrtype:    EXTERNALPOINTER                         {
                                                                $$ = new ExternalPointerTypeNode($1);
                                                                $$ -> set_location(@1);
                                                            }
               ;

bytecodetype:       BYTECODE                                {
                                                                $$ = new BytecodeTypeNode($1);
                                                                $$ -> set_location(@1);
                                                            }
            ;

pairlisttype:       PAIRLIST                                {
                                                                $$ = new PairlistTypeNode($1);
                                                                $$ -> set_location(@1);
                                                            }
            ;

s4type:             S4                                      {
                                                                $$ = new S4TypeNode($1);
                                                                $$ -> set_location(@1);
                                                            }
      ;

anytype:            ANY                                     {
                                                                $$ = new AnyTypeNode($1);
                                                                $$ -> set_location(@1);
                                                            }
       ;

vectortype:         scalartype "[" "]"                      {
                                                                $$ = new VectorTypeNode(std::move(wrap(std::move($1))));
                                                                $$ -> set_location(@$);
                                                            }
          ;

nonavectortype:     "!" vectortype                          {
                                                                $$ = new NoNaTypeNode(std::move(wrap(std::move($2))));
                                                                $$ -> set_location(@$);
                                                            }
              ;

listtype:           "((" typeseq "))"                       {
                                                                $$ = new ListTypeNode(std::move(wrap(std::move($2))));
                                                                $$ -> set_location(@$);
                                                            }
        ;

typeseq:            %empty                                  {
                                                                $$ = new TypeNodeSequenceNode();
                                                                $$ -> set_location(@$);
                                                            }
       |            type                                    {
                                                                $$ = new TypeNodeSequenceNode();
                                                                $$ -> push_back(std::move(wrap(std::move($1))));
                                                                $$ -> set_location(@$);
                                                            }
       |            typeseq "," type                        {
                                                                $$ = $1;
                                                                $1 = nullptr;
                                                                $$ -> push_back(std::move(wrap(std::move($3))));
                                                                $$ -> set_location(@$);
                                                            }
       ;

structtype:         "{{" namedtypeseq "}}"                  {
                                                                $$ = new StructTypeNode(std::move(wrap(std::move($2))));
                                                                $$ -> set_location(@$);
                                                            }
          ;


identifier:         INTEGER                                 {
                                                                $$ = new IdentifierNode($1);
                                                                $$ -> set_location(@1);
                                                            }
          |         DOUBLE                                  {
                                                                $$ = new IdentifierNode($1);
                                                                $$ -> set_location(@1);
                                                            }
          |         COMPLEX                                 {
                                                                $$ = new IdentifierNode($1);
                                                                $$ -> set_location(@1);
                                                            }
          |         CHARACTER                               {
                                                                $$ = new IdentifierNode($1);
                                                                $$ -> set_location(@1);
                                                            }
          |         LOGICAL                                 {
                                                                $$ = new IdentifierNode($1);
                                                                $$ -> set_location(@1);
                                                            }
          |         RAW                                     {
                                                                $$ = new IdentifierNode($1);
                                                                $$ -> set_location(@1);
                                                            }
          |         ENVIRONMENT                             {
                                                                $$ = new IdentifierNode($1);
                                                                $$ -> set_location(@1);
                                                            }
          |         EXPRESSION                              {
                                                                $$ = new IdentifierNode($1);
                                                                $$ -> set_location(@1);
                                                            }
          |         LANGUAGE                                {
                                                                $$ = new IdentifierNode($1);
                                                                $$ -> set_location(@1);
                                                            }
          |         SYMBOL                                  {
                                                                $$ = new IdentifierNode($1);
                                                                $$ -> set_location(@1);
                                                            }
          |         EXTERNALPOINTER                         {
                                                                $$ = new IdentifierNode($1);
                                                                $$ -> set_location(@1);
                                                            }
          |         BYTECODE                                {
                                                                $$ = new IdentifierNode($1);
                                                                $$ -> set_location(@1);
                                                            }
          |         PAIRLIST                                {
                                                                $$ = new IdentifierNode($1);
                                                                $$ -> set_location(@1);
                                                            }
          |         S4                                      {
                                                                $$ = new IdentifierNode($1);
                                                                $$ -> set_location(@1);
                                                            }
          |         ANY                                     {
                                                                $$ = new IdentifierNode($1);
                                                                $$ -> set_location(@1);
                                                            }
          |         TYPEDECL                                {
                                                                $$ = new IdentifierNode($1);
                                                                $$ -> set_location(@1);
                                                            }
          |         VARARG                                  {
                                                                $$ = new IdentifierNode($1);
                                                                $$ -> set_location(@1);
                                                            }
          |         IDENTIFIER                              {
                                                                $$ = new IdentifierNode($1);
                                                                $$ -> set_location(@1);
                                                            }
          ;

namedtype:          identifier ":" type                     {
                                                                $$ = new TagTypePairNode(std::move(wrap(std::move($1))), std::move(wrap(std::move($3))));
                                                                $$ -> set_location(@$);
                                                            }
         ;

namedtypeseq:       %empty                                  {
                                                                $$ = new TagTypePairNodeSequenceNode();
                                                                $$ -> set_location(@$);
                                                            }
            |       namedtype                               {
                                                                $$ = new TagTypePairNodeSequenceNode();
                                                                $$ -> push_back(std::move(wrap(std::move($1))));
                                                                $$ -> set_location(@1);
                                                            }
            |       namedtypeseq "," namedtype              {
                                                                $$ = $1;
                                                                $1 = nullptr;
                                                                $$ -> push_back(std::move(wrap(std::move($3))));
                                                                $$ -> set_location(@$);
                                                            }
            ;


paramtype:          type                                    {
                                                                $$ = $1;
                                                                $1 = nullptr;
                                                                $$ -> set_location(@1);
                                                            }
         |          "..."                                   {
                                                                $$ = new VarargTypeNode();
                                                                $$ -> set_location(@1);
                                                            }
         ;

paramtypeseq:       %empty                                  {
                                                                $$ = new TypeNodeSequenceNode();
                                                                $$ -> set_location(@$);
                                                            }
            |       paramtype                               {
                                                                $$ = new TypeNodeSequenceNode();
                                                                $$ -> push_back(std::move(wrap(std::move($1))));
                                                                $$ -> set_location(@$);
                                                            }
            |       paramtypeseq "," paramtype              {
                                                                $$ = $1;
                                                                $1 = nullptr;
                                                                $$ -> push_back(std::move(wrap(std::move($3))));
                                                                $$ -> set_location(@$);
                                                            }
            ;

functiontype:       "<" paramtypeseq ">" "=>" type          {
                                                                $$ = new FunctionTypeNode(std::move(wrap(std::move($2))), std::move(wrap(std::move($5))));
                                                                $$ -> set_location(@$);
                                                            }

grouptype:          "(" type ")"                            {
                                                                $$ = new GroupTypeNode(std::move(wrap(std::move($2))));
                                                                $$ -> set_location(@$);
                                                            }
         ;

nonuniontype:       scalartype                              {
                                                                $$ = $1;
                                                                $1 = nullptr;
                                                                $$ -> set_location(@$);
                                                            }
            |       environmenttype                         {
                                                                $$ = $1;
                                                                $1 = nullptr;
                                                                $$ -> set_location(@$);
                                                            }
            |       expressiontype                          {
                                                                $$ = $1;
                                                                $1 = nullptr;
                                                                $$ -> set_location(@$);
                                                            }
            |       languagetype                            {
                                                                $$ = $1;
                                                                $1 = nullptr;
                                                                $$ -> set_location(@$);
                                                            }
            |       symboltype                              {
                                                                $$ = $1;
                                                                $1 = nullptr;
                                                                $$ -> set_location(@$);
                                                            }
            |       externalptrtype                         {
                                                                $$ = $1;
                                                                $1 = nullptr;
                                                                $$ -> set_location(@$);
                                                            }
            |       bytecodetype                            {
                                                                $$ = $1;
                                                                $1 = nullptr;
                                                                $$ -> set_location(@$);
                                                            }
            |       pairlisttype                            {
                                                                $$ = $1;
                                                                $1 = nullptr;
                                                                $$ -> set_location(@$);
                                                            }
            |       s4type                                  {
                                                                $$ = $1;
                                                                $1 = nullptr;
                                                                $$ -> set_location(@$);
                                                            }
            |       anytype                                 {
                                                                $$ = $1;
                                                                $1 = nullptr;
                                                                $$ -> set_location(@$);
                                                            }
            |       vectortype                              {
                                                                $$ = $1;
                                                                $1 = nullptr;
                                                                $$ -> set_location(@$);
                                                            }
            |       nonavectortype                          {
                                                                $$ = $1;
                                                                $1 = nullptr;
                                                                $$ -> set_location(@$);
                                                            }
            |       functiontype                            {
                                                                $$ = $1;
                                                                $1 = nullptr;
                                                                $$ -> set_location(@$);
                                                            }
            |       structtype                              {
                                                                $$ = $1;
                                                                $1 = nullptr;
                                                                $$ -> set_location(@$);
                                                            }
            |       listtype                                {
                                                                $$ = $1;
                                                                $1 = nullptr;
                                                                $$ -> set_location(@$);
                                                            }
            |       grouptype                               {
                                                                $$ = $1;
                                                                $1 = nullptr;
                                                                $$ -> set_location(@$);
                                                            }
            ;


type:               nonuniontype                            {
                                                                $$ = $1;
                                                                $1 = nullptr;
                                                                $$ -> set_location(@$);
                                                            }
    |               type "|" nonuniontype                   {
                                                                $$ = new UnionTypeNode(std::move(wrap(std::move($1))), std::move(wrap(std::move($3))));
                                                                $$ -> set_location(@$);
                                                            }
    ;


decltype:           TYPEDECL identifier type ";"            {
                                                                $$ = new TypeDeclarationNode(std::move(wrap(std::move($2))), std::move(wrap(std::move($3))));
                                                                $$ -> set_location(@$);
                                                            }
        ;

decllist:           decltype                                {
                                                                context.get_top_level_node() -> get_type_declarations().push_back(std::move(wrap(std::move($1))));
                                                            }
        |           decllist decltype                       {
                                                                context.get_top_level_node() -> get_type_declarations().push_back(std::move(wrap(std::move($2))));
                                                            }
        ;

start:              EOF                                     { }
     |              decllist EOF                            { context.get_top_level_node() -> set_location(@$); }
     ;

%%

void tastr::parser::Parser::error(const location_type& location, const std::string& message) {
    std::cout << "Parser Error: " << location << " :: " << message << std::endl;
}
