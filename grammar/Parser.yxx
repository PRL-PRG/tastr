/* -*- C++ -*- */
%output  "Parser.cxx"
%defines "Parser.hxx"

%skeleton "lalr1.cc"
%require "3.5.2"

%define api.parser.class {Parser}
%define api.namespace {tastr::parser}

/* assert correct cleanup of semantic value objects */
%define parse.assert

%define parse.trace

/* increase usefulness of error messages */
%define parse.error verbose
%parse-param { tastr::parser::Lexer& lexer} { tastr::parser::ParsingContext& context }

/* call yylex with a location */
%locations

%define api.value.type variant
/* %define api.token.constructor */
%define api.token.prefix {TOKEN_}


%token EOF                          0             "end of file";
%token <std::string>                OR            "|";
%token <std::string>                EXCLAMATION   "!";
%token <std::string>                ARROW         "=>";
%token <std::string>                COMMA         ",";
%token <std::string>                DOUBLE_LPAREN "((";
%token <std::string>                LPAREN        "(";
%token <std::string>                DOUBLE_RPAREN "))";
%token <std::string>                RPAREN        ")";
%token <std::string>                LBRACKET      "[";
%token <std::string>                RBRACKET      "]";
%token <std::string>                LANGLEBRACKET "<";
%token <std::string>                RANGLEBRACKET ">";
%token <std::string>                DOUBLE_LBRACE "{{";
%token <std::string>                DOUBLE_RBRACE "}}";
%token <std::string>                SEMICOLON     ";";
%token <std::string>                COLON         ":";
%token <std::string>                VARARG        "...";
%token <std::string>                INTEGER
%token <std::string>                DOUBLE
%token <std::string>                COMPLEX
%token <std::string>                CHARACTER
%token <std::string>                LOGICAL
%token <std::string>                RAW
%token <std::string>                ENVIRONMENT
%token <std::string>                EXPRESSION
%token <std::string>                LANGUAGE
%token <std::string>                SYMBOL
%token <std::string>                TYPEDECL
%token <std::string>                IDENTIFIER;
%nterm <ScalarTypeNodePtr>              scalartype
%nterm <EnvironmentTypeNodePtr>         environmenttype
%nterm <ExpressionTypeNodePtr>          expressiontype
%nterm <LanguageTypeNodePtr>            languagetype
%nterm <SymbolTypeNodePtr>              symboltype
%nterm <VectorTypeNodePtr>              vectortype
%nterm <NoNaTypeNodePtr>                nonavectortype
%nterm <sequence_ptr_t<TypeNode>>       typeseq
%nterm <TaggedTypeNodePtr>              namedtype
%nterm <sequence_ptr_t<TaggedTypeNode>> namedtypeseq
%nterm <TypeNodePtr>                    paramtype
%nterm <sequence_ptr_t<TypeNode>>       paramtypeseq
%nterm <FunctionTypeNodePtr>            functiontype
%nterm <GroupTypeNodePtr>               grouptype
%nterm <TypeNodePtr>                    nonuniontype
%nterm <ListTypeNodePtr>                listtype
%nterm <StructTypeNodePtr>              structtype
%nterm <IdentifierNodePtr>              funname
%nterm <IdentifierNodePtr>              identifier
%nterm <TypeNodePtr>                    type
%nterm <TypeDeclarationNodePtr>         decltype


%right ARROW
%nonassoc COMMA EXCLAMATION LPAREN LBRACKET LANGLEBRACKET
%left OR


%start start;

/*
%printer { yyo << to_string(*$$); } <TypeNodePtr>;
%printer { yyo << to_string(*$$); } <VectorTypeNodePtr>;
%printer { yyo << to_string(*$$); } <NoNaTypeNodePtr>;
%printer { yyo << to_string(*$$); } <FunctionTypeNodePtr>;
%printer { yyo << to_string(*$$); } <GroupTypeNodePtr>;
%printer { yyo << to_string(*$$); } <ListTypeNodePtr>;
%printer { yyo << to_string(*$$); } <StructTypeNodePtr>;
%printer { yyo << to_string(*$$); } <ScalarTypeNodePtr>;
*/
/*%printer { yyo << $$; } <*>; */

/*
%destructor { delete $$; } scalartype
%destructor { delete $$; } vectortype
%destructor { delete $$; } nonavectortype
%destructor { delete $$; } typeseq
%destructor { delete $$; } namedtypeseq
%destructor { delete $$; } functiontype
%destructor { delete $$; } grouptype
%destructor { delete $$; } nonuniontype
%destructor { delete $$; } listtype
%destructor { delete $$; } structtype
%destructor { delete $$; } type
*/


%initial-action {
    /* filename for locations here             
       https://www.gnu.org/software/bison/manual/html_node/Initial-Action-Decl.html */
    @$.initialize(context.get_input_stream_name());
}

/* inserted near top of header + source file */
%code requires {
    namespace tastr::parser {
        class Lexer;
        class ParsingContext;
    }
    #include "location.hh"
    #include "ast.h"
    using tastr::ast::CharacterTypeNode;
    using tastr::ast::ComplexTypeNode;
    using tastr::ast::DoubleTypeNode;
    using tastr::ast::ExpressionTypeNode;
    using tastr::ast::ExpressionTypeNodePtr;
    using tastr::ast::EnvironmentTypeNode;
    using tastr::ast::EnvironmentTypeNodePtr;
    using tastr::ast::LanguageTypeNode;
    using tastr::ast::LanguageTypeNodePtr;
    using tastr::ast::SymbolTypeNode;
    using tastr::ast::SymbolTypeNodePtr;
    using tastr::ast::FunctionTypeNode;
    using tastr::ast::FunctionTypeNodePtr;
    using tastr::ast::GroupTypeNode;
    using tastr::ast::GroupTypeNodePtr;
    using tastr::ast::IntegerTypeNode;
    using tastr::ast::ListTypeNode;
    using tastr::ast::ListTypeNodePtr;
    using tastr::ast::LogicalTypeNode;
    using tastr::ast::TaggedTypeNode;
    using tastr::ast::TaggedTypeNodePtr;
    using tastr::ast::TaggedTypeNodeUPtr;
    using tastr::ast::NoNaTypeNode;
    using tastr::ast::NoNaTypeNodePtr;
    using tastr::ast::ParameterTypeNode;
    using tastr::ast::ParameterTypeNodePtr;
    using tastr::ast::ParameterTypeNodeUPtr;
    using tastr::ast::RawTypeNode;
    using tastr::ast::ScalarTypeNodePtr;
    using tastr::ast::ScalarTypeNodeUPtr;
    using tastr::ast::sequence_t;
    using tastr::ast::sequence_ptr_t;
    using tastr::ast::sequence_uptr_t;
    using tastr::ast::StructTypeNode;
    using tastr::ast::StructTypeNodePtr;
    using tastr::ast::TypeNode;
    using tastr::ast::TypeNodePtr;
    using tastr::ast::TypeNodeUPtr;
    using tastr::ast::UnionTypeNode;
    using tastr::ast::UnionTypeNodePtr;
    using tastr::ast::VectorTypeNode;
    using tastr::ast::VectorTypeNodePtr;
    using tastr::ast::VectorTypeNodeUPtr;
    using tastr::ast::TypeDeclarationNode;
    using tastr::ast::TypeDeclarationNodePtr;
    using tastr::ast::TypeDeclarationNodeUPtr;
    using tastr::ast::TypeDeclarationSequenceNodeUPtr;
    using tastr::ast::IdentifierNode;
    using tastr::ast::IdentifierNodePtr;
    using tastr::ast::IdentifierNodeUPtr;
    using tastr::ast::VarargTypeNode;
}

/* inserted near top of source file */
%code {
    #include "ParsingContext.h"
    #include "Lexer.hpp"
    #undef yylex
    #define yylex lexer.yylex
}

%%

scalartype:         INTEGER                                 {
                                                                $$ = new IntegerTypeNode();
                                                            }
          |         DOUBLE                                  {
                                                                $$ = new DoubleTypeNode();
                                                            }
          |         COMPLEX                                 {
                                                                $$ = new ComplexTypeNode();
                                                            }
          |         CHARACTER                               {
                                                                $$ = new CharacterTypeNode();
                                                            }
          |         LOGICAL                                 {
                                                                $$ = new LogicalTypeNode();
                                                            }
          |         RAW                                     {
                                                                $$ = new RawTypeNode();
                                                            }
          ;

environmenttype:    ENVIRONMENT                             {
                                                                $$ = new EnvironmentTypeNode();
                                                            }
               ;

expressiontype:     EXPRESSION                              {
                                                                $$ = new ExpressionTypeNode();
                                                            }
              ;

languagetype:       LANGUAGE                                {
                                                                $$ = new LanguageTypeNode();
                                                            }
            ;

symboltype:         SYMBOL                                  {
                                                                $$ = new SymbolTypeNode();
                                                            }
          ;

vectortype:         scalartype "[" "]"                      {
                                                                ScalarTypeNodeUPtr scalar_type($1);
                                                                $$ = new VectorTypeNode(std::move(scalar_type));
                                                            }
          ;

nonavectortype:     "!" vectortype                          {
                                                                VectorTypeNodeUPtr vector_type($2);
                                                                $$ = new NoNaTypeNode(std::move(vector_type));
                                                            }
              ;

listtype:           "((" typeseq "))"                       {
                                                                sequence_uptr_t<TypeNode> sequence($2);
                                                                $$ = new ListTypeNode(std::move(sequence));
                                                            }
        ;

typeseq:            %empty                                  {
                                                                $$ = new sequence_t<TypeNode>();
                                                            }
       |            type                                    {
                                                                TypeNodeUPtr type($1);
                                                                $$ = new sequence_t<TypeNode>();
                                                                $$ -> push_back(std::move(type));
                                                            }
       |            typeseq "," type                        {
                                                                TypeNodeUPtr type($3);
                                                                $1 -> push_back(std::move(type));
                                                                $$ = $1;
                                                            }
       ;

structtype:         "{{" namedtypeseq "}}"                  {
                                                                sequence_uptr_t<TaggedTypeNode> sequences($2);
                                                                $$ = new StructTypeNode(std::move(sequences));
                                                            }
          ;


identifier:         INTEGER                                 { $$ = new IdentifierNode($1); }
          |         DOUBLE                                  { $$ = new IdentifierNode($1); }
          |         COMPLEX                                 { $$ = new IdentifierNode($1); }
          |         CHARACTER                               { $$ = new IdentifierNode($1); }
          |         LOGICAL                                 { $$ = new IdentifierNode($1); }
          |         RAW                                     { $$ = new IdentifierNode($1); }
          |         ENVIRONMENT                             { $$ = new IdentifierNode($1); }
          |         EXPRESSION                              { $$ = new IdentifierNode($1); }
          |         LANGUAGE                                { $$ = new IdentifierNode($1); }
          |         SYMBOL                                  { $$ = new IdentifierNode($1); }
          |         TYPEDECL                                { $$ = new IdentifierNode($1); }
          |         VARARG                                  { $$ = new IdentifierNode($1); }
          |         IDENTIFIER                              { $$ = new IdentifierNode($1); }
          ;

namedtype:          identifier ":" type                     {
                                                                IdentifierNodeUPtr ident($1);
                                                                TypeNodeUPtr type($3);
                                                                $$ = new TaggedTypeNode(std::move(ident), std::move(type));
                                                            }
         ;

namedtypeseq:       %empty                                  {
                                                                $$ = new sequence_t<TaggedTypeNode>();
                                                            }
            |       namedtype                               {
                                                                TaggedTypeNodeUPtr named_type($1);
                                                                $$ = new sequence_t<TaggedTypeNode>();
                                                                $$ -> push_back(std::move(named_type));
                                                            }
            |       namedtypeseq "," namedtype              {
                                                                TaggedTypeNodeUPtr named_type($3);
                                                                $1 -> push_back(std::move(named_type));
                                                                $$ = $1;
                                                            }
            ;


paramtype:          type                                    {   $$ = $1;               }
         |          "..."                                   {   $$ = new VarargTypeNode(); }
         ;

paramtypeseq:       %empty                                  {
                                                                $$ = new sequence_t<TypeNode>();
                                                            }
            |       paramtype                               {
                                                                TypeNodeUPtr type($1);
                                                                $$ = new sequence_t<TypeNode>();
                                                                $$ -> push_back(std::move(type));
                                                            }
            |       paramtypeseq "," paramtype              {
                                                                TypeNodeUPtr type($3);
                                                                $1 -> push_back(std::move(type));
                                                                $$ = $1;
                                                            }
            ;

functiontype:       "<" paramtypeseq ">" "=>" type          {
                                                                sequence_uptr_t<TypeNode> sequence($2);
                                                                ParameterTypeNodePtr types = new ParameterTypeNode(std::move(sequence));
                                                                ParameterTypeNodeUPtr parameter_types(types);
                                                                TypeNodeUPtr return_type($5);
                                                                $$ = new FunctionTypeNode(std::move(parameter_types), std::move(return_type));
                                                            }

grouptype:          "(" type ")"                            {
                                                                TypeNodeUPtr type($2);
                                                                $$ = new GroupTypeNode(std::move(type));
                                                            }
         ;

nonuniontype:       scalartype                              {   $$ = $1; }
            |       environmenttype                         {   $$ = $1; }
            |       expressiontype                          {   $$ = $1; }
            |       languagetype                            {   $$ = $1; }
            |       symboltype                              {   $$ = $1; }
            |       vectortype                              {   $$ = $1; }
            |       nonavectortype                          {   $$ = $1; }
            |       functiontype                            {   $$ = $1; }
            |       structtype                              {   $$ = $1; }
            |       listtype                                {   $$ = $1; }
            |       grouptype                               {   $$ = $1; }
            ;


type:               nonuniontype                            {   $$ = $1; }
    |               type "|" nonuniontype                   {
                                                                TypeNodeUPtr left_type($1);
                                                                TypeNodeUPtr right_type($3);
                                                                $$ = new UnionTypeNode(std::move(left_type), std::move(right_type));
                                                            }
    ;


funname:            INTEGER                                 { $$ = new IdentifierNode($1); }
       |            DOUBLE                                  { $$ = new IdentifierNode($1); }
       |            COMPLEX                                 { $$ = new IdentifierNode($1); }
       |            CHARACTER                               { $$ = new IdentifierNode($1); }
       |            LOGICAL                                 { $$ = new IdentifierNode($1); }
       |            RAW                                     { $$ = new IdentifierNode($1); }
       |            ENVIRONMENT                             { $$ = new IdentifierNode($1); }
       |            EXPRESSION                              { $$ = new IdentifierNode($1); }
       |            LANGUAGE                                { $$ = new IdentifierNode($1); }
       |            SYMBOL                                  { $$ = new IdentifierNode($1); }
       |            TYPEDECL                                { $$ = new IdentifierNode($1); }
       |            IDENTIFIER                              { $$ = new IdentifierNode($1); }
       ;


decltype:           TYPEDECL funname type ";"               {
                                                                IdentifierNodeUPtr identifier($2);
                                                                TypeNodeUPtr type($3);
                                                                $$ = new TypeDeclarationNode(std::move(identifier), std::move(type));
                                                            }
        ;

decllist:           decltype                                {
                                                                TypeDeclarationNodeUPtr type_decl($1);
                                                                context.get_type_declaration_sequence() -> push_back(std::move(type_decl));
                                                            }
        |           decllist decltype                       {
                                                                TypeDeclarationNodeUPtr type_decl($2);
                                                                context.get_type_declaration_sequence() -> push_back(std::move(type_decl));
                                                            }
        ;

start:              EOF                                     { }
     |              decllist EOF                            { }
     ;

%%

void tastr::parser::Parser::error(const location_type& location, const std::string& message) {
    std::cout << "Parser Error: " << location << " :: " << message << std::endl;
}
